{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Project Setup and Build Configuration",
        "description": "Initialize the Chrome extension project with TypeScript, Vite build system, and folder structure according to the architecture specification",
        "details": "1. Initialize npm project with `npm init`\n2. Install dependencies:\n   - TypeScript 5+: `npm install -D typescript @types/chrome`\n   - Vite: `npm install -D vite vite-plugin-web-extension`\n   - CSS tooling: `npm install -D tailwindcss postcss autoprefixer` (or CSS Modules setup)\n3. Create tsconfig.json with strict mode:\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2020\",\n    \"module\": \"ESNext\",\n    \"lib\": [\"ES2020\", \"DOM\"],\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"moduleResolution\": \"node\",\n    \"resolveJsonModule\": true,\n    \"types\": [\"chrome\"]\n  }\n}\n```\n4. Create folder structure:\n   - background/\n   - content/ (inspector.ts, overlay.ts, extractor.ts)\n   - popup/ (popup.html, popup.ts, popup.css)\n   - panel/ (panel.html, panel.ts, panel.css)\n   - shared/ (types.ts, utils.ts, constants.ts)\n5. Configure Vite build (vite.config.ts) to bundle extension with proper entry points\n6. Add build scripts to package.json: `build`, `dev`, `watch`\n7. Create .gitignore (node_modules, dist, .env)\n8. Initialize README.md with project overview",
        "testStrategy": "1. Run `npm run build` and verify dist/ folder is created\n2. Check that all TypeScript files compile without errors\n3. Verify folder structure matches specification\n4. Ensure build output includes all necessary files for Chrome extension\n5. Test hot reload in dev mode with `npm run dev`",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-10T17:20:52.758Z"
      },
      {
        "id": 2,
        "title": "Create Manifest V3 Configuration and Shared Types",
        "description": "Implement manifest.json with Manifest V3 specification and create TypeScript interfaces for all data structures",
        "details": "1. Create manifest.json in root/public folder:\n```json\n{\n  \"manifest_version\": 3,\n  \"name\": \"Pixel Perfect Inspector\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Inspect and extract CSS properties from DOM elements with pixel-perfect precision\",\n  \"permissions\": [\"activeTab\", \"storage\", \"scripting\"],\n  \"host_permissions\": [\"http://localhost/*\", \"https://*/*\"],\n  \"background\": {\n    \"service_worker\": \"background/service-worker.js\"\n  },\n  \"action\": {\n    \"default_popup\": \"popup/popup.html\",\n    \"default_icon\": {\n      \"16\": \"icons/icon16.png\",\n      \"48\": \"icons/icon48.png\",\n      \"128\": \"icons/icon128.png\"\n    }\n  },\n  \"content_scripts\": [{\n    \"matches\": [\"http://localhost/*\", \"https://*/*\"],\n    \"js\": [\"content/inspector.js\"],\n    \"css\": [\"content/overlay.css\"]\n  }],\n  \"icons\": {\n    \"16\": \"icons/icon16.png\",\n    \"48\": \"icons/icon48.png\",\n    \"128\": \"icons/icon128.png\"\n  }\n}\n```\n2. Create shared/types.ts with all interfaces from PRD:\n   - InspectedElement\n   - CSSProperties (Typography, Spacing, Dimensions, Borders, Layout)\n   - ElementPosition\n   - ExtensionState (for managing inspection mode)\n3. Create shared/constants.ts:\n   - OVERLAY_COLOR, OVERLAY_WIDTH\n   - CSS_PROPERTIES_TO_EXTRACT (array of property names)\n   - STORAGE_KEYS\n   - KEYBOARD_SHORTCUTS\n4. Create shared/utils.ts with helper functions:\n   - generateUniqueId()\n   - formatCSSValue()\n   - parseUnit(value: string): {value: number, unit: string}\n5. Create placeholder icons (16x16, 48x48, 128x128) in icons/ folder",
        "testStrategy": "1. Validate manifest.json against Chrome Extension Manifest V3 schema\n2. Load extension in Chrome (chrome://extensions) in developer mode\n3. Verify no manifest errors appear\n4. Check TypeScript compilation succeeds with all type definitions\n5. Test that types are properly exported and importable across modules",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-10T17:20:52.760Z"
      },
      {
        "id": 3,
        "title": "Implement Background Service Worker",
        "description": "Create the background service worker to manage extension state, handle messages between components, and coordinate inspection mode activation",
        "details": "1. Create background/service-worker.ts:\n```typescript\nimport { ExtensionState } from '../shared/types';\n\nlet inspectionMode = false;\nlet activeTabId: number | null = null;\n\n// Listen for extension icon click\nchrome.action.onClicked.addListener(async (tab) => {\n  if (!tab.id) return;\n  activeTabId = tab.id;\n  \n  // Toggle inspection mode\n  inspectionMode = !inspectionMode;\n  \n  // Inject content script if not already injected\n  await chrome.scripting.executeScript({\n    target: { tabId: tab.id },\n    files: ['content/inspector.js']\n  });\n  \n  // Send message to content script\n  chrome.tabs.sendMessage(tab.id, {\n    action: 'toggleInspection',\n    enabled: inspectionMode\n  });\n  \n  // Update icon to reflect state\n  chrome.action.setIcon({\n    path: inspectionMode ? 'icons/icon-active.png' : 'icons/icon.png',\n    tabId: tab.id\n  });\n});\n\n// Handle messages from content scripts and popup\nchrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n  switch (message.action) {\n    case 'getInspectionState':\n      sendResponse({ enabled: inspectionMode });\n      break;\n    case 'saveInspectedElement':\n      // Save to chrome.storage\n      chrome.storage.local.get(['history'], (result) => {\n        const history = result.history || [];\n        history.unshift(message.element);\n        // Keep only last 10\n        const trimmed = history.slice(0, 10);\n        chrome.storage.local.set({ history: trimmed });\n      });\n      break;\n    case 'disableInspection':\n      inspectionMode = false;\n      if (sender.tab?.id) {\n        chrome.action.setIcon({\n          path: 'icons/icon.png',\n          tabId: sender.tab.id\n        });\n      }\n      break;\n  }\n  return true;\n});\n\n// Handle keyboard shortcuts\nchrome.commands.onCommand.addListener((command) => {\n  if (command === 'toggle-inspection') {\n    chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {\n      if (tabs[0]?.id) {\n        chrome.action.onClicked.dispatch(tabs[0]);\n      }\n    });\n  }\n});\n```\n2. Add keyboard shortcuts to manifest.json:\n```json\n\"commands\": {\n  \"toggle-inspection\": {\n    \"suggested_key\": {\n      \"default\": \"Ctrl+Shift+I\",\n      \"mac\": \"Command+Shift+I\"\n    },\n    \"description\": \"Toggle inspection mode\"\n  }\n}\n```",
        "testStrategy": "1. Load extension and verify service worker starts without errors\n2. Click extension icon and check console for messages\n3. Verify chrome.storage operations work correctly\n4. Test message passing between service worker and content script\n5. Test keyboard shortcut triggers inspection mode\n6. Verify icon changes state when inspection mode toggles",
        "priority": "high",
        "dependencies": [
          "2"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-10T17:20:52.761Z"
      },
      {
        "id": 4,
        "title": "Implement CSS Property Extractor",
        "description": "Create the core CSS extraction logic that retrieves computed styles from DOM elements and structures them according to the defined TypeScript interfaces",
        "details": "1. Create content/extractor.ts:\n```typescript\nimport { CSSProperties, Typography, Spacing, Dimensions, Borders, Layout, InspectedElement } from '../shared/types';\nimport { parseUnit, generateUniqueId } from '../shared/utils';\n\nexport class CSSExtractor {\n  extractProperties(element: HTMLElement): CSSProperties {\n    const computed = window.getComputedStyle(element);\n    \n    return {\n      typography: this.extractTypography(computed),\n      spacing: this.extractSpacing(computed),\n      dimensions: this.extractDimensions(element, computed),\n      borders: this.extractBorders(computed),\n      layout: this.extractLayout(computed)\n    };\n  }\n  \n  private extractTypography(computed: CSSStyleDeclaration): Typography {\n    const fontSize = parseUnit(computed.fontSize);\n    const lineHeight = parseUnit(computed.lineHeight);\n    \n    return {\n      fontFamily: computed.fontFamily,\n      fontSize,\n      fontWeight: computed.fontWeight,\n      lineHeight,\n      color: this.rgbToHex(computed.color),\n      letterSpacing: computed.letterSpacing !== 'normal' ? computed.letterSpacing : undefined,\n      textTransform: computed.textTransform !== 'none' ? computed.textTransform : undefined\n    };\n  }\n  \n  private extractSpacing(computed: CSSStyleDeclaration): Spacing {\n    return {\n      padding: {\n        top: computed.paddingTop,\n        right: computed.paddingRight,\n        bottom: computed.paddingBottom,\n        left: computed.paddingLeft\n      },\n      margin: {\n        top: computed.marginTop,\n        right: computed.marginRight,\n        bottom: computed.marginBottom,\n        left: computed.marginLeft\n      },\n      gap: computed.gap !== 'normal' ? computed.gap : undefined\n    };\n  }\n  \n  private extractDimensions(element: HTMLElement, computed: CSSStyleDeclaration): Dimensions {\n    const rect = element.getBoundingClientRect();\n    \n    return {\n      width: {\n        value: parseFloat(computed.width),\n        unit: parseUnit(computed.width).unit,\n        computed: rect.width\n      },\n      height: {\n        value: parseFloat(computed.height),\n        unit: parseUnit(computed.height).unit,\n        computed: rect.height\n      },\n      minWidth: computed.minWidth !== 'none' ? computed.minWidth : undefined,\n      maxWidth: computed.maxWidth !== 'none' ? computed.maxWidth : undefined,\n      minHeight: computed.minHeight !== 'none' ? computed.minHeight : undefined,\n      maxHeight: computed.maxHeight !== 'none' ? computed.maxHeight : undefined\n    };\n  }\n  \n  private extractBorders(computed: CSSStyleDeclaration): Borders {\n    return {\n      borderRadius: {\n        topLeft: computed.borderTopLeftRadius,\n        topRight: computed.borderTopRightRadius,\n        bottomRight: computed.borderBottomRightRadius,\n        bottomLeft: computed.borderBottomLeftRadius\n      },\n      border: {\n        width: computed.borderWidth,\n        style: computed.borderStyle,\n        color: this.rgbToHex(computed.borderColor)\n      }\n    };\n  }\n  \n  private extractLayout(computed: CSSStyleDeclaration): Layout {\n    const layout: Layout = {\n      display: computed.display,\n      position: computed.position\n    };\n    \n    if (computed.display === 'flex' || computed.display === 'inline-flex') {\n      layout.flexDirection = computed.flexDirection;\n      layout.justifyContent = computed.justifyContent;\n      layout.alignItems = computed.alignItems;\n    }\n    \n    return layout;\n  }\n  \n  private rgbToHex(rgb: string): string {\n    const match = rgb.match(/^rgb\\((\\d+),\\s*(\\d+),\\s*(\\d+)\\)$/);\n    if (!match) return rgb;\n    \n    const hex = (x: string) => (\"0\" + parseInt(x).toString(16)).slice(-2);\n    return \"#\" + hex(match[1]) + hex(match[2]) + hex(match[3]);\n  }\n  \n  createInspectedElement(element: HTMLElement): InspectedElement {\n    const rect = element.getBoundingClientRect();\n    \n    return {\n      id: generateUniqueId(),\n      timestamp: Date.now(),\n      selector: this.generateSelector(element),\n      tagName: element.tagName.toLowerCase(),\n      className: element.className,\n      properties: this.extractProperties(element),\n      position: {\n        x: rect.left + window.scrollX,\n        y: rect.top + window.scrollY,\n        width: rect.width,\n        height: rect.height\n      }\n    };\n  }\n  \n  private generateSelector(element: HTMLElement): string {\n    if (element.id) return `#${element.id}`;\n    if (element.className) {\n      const classes = element.className.split(' ').filter(c => c).join('.');\n      return `${element.tagName.toLowerCase()}.${classes}`;\n    }\n    return element.tagName.toLowerCase();\n  }\n}\n```\n2. Implement parseUnit() in shared/utils.ts:\n```typescript\nexport function parseUnit(value: string): { value: number; unit: string } {\n  const match = value.match(/^([\\d.]+)([a-z%]*)$/);\n  if (!match) return { value: 0, unit: '' };\n  return {\n    value: parseFloat(match[1]),\n    unit: match[2] || 'px'\n  };\n}\n```",
        "testStrategy": "1. Unit test extractProperties() with mock DOM elements\n2. Test each extraction method (typography, spacing, dimensions, borders, layout) independently\n3. Verify rgbToHex() converts colors correctly\n4. Test with elements having various CSS properties (flex, grid, positioned elements)\n5. Verify computed values match actual rendered values\n6. Test edge cases: elements with no styles, inline styles, inherited styles\n7. Performance test: extraction should complete in < 50ms",
        "priority": "high",
        "dependencies": [
          "2"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-10T17:31:50.665Z"
      },
      {
        "id": 5,
        "title": "Implement Visual Overlay and Hover Highlighting",
        "description": "Create the visual overlay system that highlights elements on hover with colored borders and tooltips showing basic element information",
        "details": "1. Create content/overlay.ts:\n```typescript\nimport { OVERLAY_COLOR, OVERLAY_WIDTH } from '../shared/constants';\n\nexport class OverlayManager {\n  private overlayElement: HTMLDivElement | null = null;\n  private tooltipElement: HTMLDivElement | null = null;\n  private isActive = false;\n  \n  constructor() {\n    this.createOverlayElements();\n  }\n  \n  private createOverlayElements() {\n    // Create overlay border\n    this.overlayElement = document.createElement('div');\n    this.overlayElement.id = 'pixel-perfect-overlay';\n    this.overlayElement.style.cssText = `\n      position: absolute;\n      pointer-events: none;\n      border: 2px solid #007AFF;\n      z-index: 2147483647;\n      display: none;\n      box-sizing: border-box;\n    `;\n    \n    // Create tooltip\n    this.tooltipElement = document.createElement('div');\n    this.tooltipElement.id = 'pixel-perfect-tooltip';\n    this.tooltipElement.style.cssText = `\n      position: absolute;\n      pointer-events: none;\n      background: #007AFF;\n      color: white;\n      padding: 4px 8px;\n      border-radius: 4px;\n      font-family: monospace;\n      font-size: 12px;\n      z-index: 2147483647;\n      display: none;\n      white-space: nowrap;\n    `;\n    \n    document.body.appendChild(this.overlayElement);\n    document.body.appendChild(this.tooltipElement);\n  }\n  \n  activate() {\n    this.isActive = true;\n  }\n  \n  deactivate() {\n    this.isActive = false;\n    this.hide();\n  }\n  \n  showOnElement(element: HTMLElement) {\n    if (!this.isActive || !this.overlayElement || !this.tooltipElement) return;\n    \n    const rect = element.getBoundingClientRect();\n    const scrollX = window.scrollX;\n    const scrollY = window.scrollY;\n    \n    // Position overlay\n    this.overlayElement.style.display = 'block';\n    this.overlayElement.style.left = `${rect.left + scrollX}px`;\n    this.overlayElement.style.top = `${rect.top + scrollY}px`;\n    this.overlayElement.style.width = `${rect.width}px`;\n    this.overlayElement.style.height = `${rect.height}px`;\n    \n    // Position tooltip\n    const tooltipText = `<${element.tagName.toLowerCase()}> ${Math.round(rect.width)}√ó${Math.round(rect.height)}px`;\n    this.tooltipElement.textContent = tooltipText;\n    this.tooltipElement.style.display = 'block';\n    \n    // Position tooltip above element, or below if not enough space\n    const tooltipTop = rect.top + scrollY - 30;\n    if (tooltipTop < scrollY) {\n      this.tooltipElement.style.top = `${rect.bottom + scrollY + 5}px`;\n    } else {\n      this.tooltipElement.style.top = `${tooltipTop}px`;\n    }\n    this.tooltipElement.style.left = `${rect.left + scrollX}px`;\n  }\n  \n  hide() {\n    if (this.overlayElement) this.overlayElement.style.display = 'none';\n    if (this.tooltipElement) this.tooltipElement.style.display = 'none';\n  }\n  \n  destroy() {\n    this.overlayElement?.remove();\n    this.tooltipElement?.remove();\n  }\n}\n```\n2. Add constants to shared/constants.ts:\n```typescript\nexport const OVERLAY_COLOR = '#007AFF';\nexport const OVERLAY_WIDTH = 2;\nexport const OVERLAY_Z_INDEX = 2147483647;\n```\n3. Create content/overlay.css for additional styling if needed",
        "testStrategy": "1. Test overlay appears on hover with correct positioning\n2. Verify overlay follows element dimensions accurately\n3. Test tooltip displays correct tag name and dimensions\n4. Test tooltip positioning (above/below element based on space)\n5. Verify overlay doesn't interfere with page interactions (pointer-events: none)\n6. Test with scrolled pages (overlay should account for scroll position)\n7. Test with fixed/absolute positioned elements\n8. Verify high z-index ensures overlay is always visible\n9. Test performance: hover should feel instant (< 16ms response time)",
        "priority": "high",
        "dependencies": [
          "2"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-10T17:31:50.666Z"
      },
      {
        "id": 6,
        "title": "Implement Inspector Content Script with Event Handling",
        "description": "Create the main inspector content script that coordinates hover detection, click handling, and communication with the panel",
        "details": "1. Create content/inspector.ts:\n```typescript\nimport { CSSExtractor } from './extractor';\nimport { OverlayManager } from './overlay';\nimport { InspectedElement } from '../shared/types';\n\nclass PixelPerfectInspector {\n  private extractor: CSSExtractor;\n  private overlay: OverlayManager;\n  private isEnabled = false;\n  private currentElement: HTMLElement | null = null;\n  private panelOpen = false;\n  \n  constructor() {\n    this.extractor = new CSSExtractor();\n    this.overlay = new OverlayManager();\n    this.setupMessageListener();\n  }\n  \n  private setupMessageListener() {\n    chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n      if (message.action === 'toggleInspection') {\n        this.toggle(message.enabled);\n        sendResponse({ success: true });\n      }\n      return true;\n    });\n  }\n  \n  toggle(enabled: boolean) {\n    this.isEnabled = enabled;\n    \n    if (enabled) {\n      this.enable();\n    } else {\n      this.disable();\n    }\n  }\n  \n  private enable() {\n    this.overlay.activate();\n    document.addEventListener('mousemove', this.handleMouseMove);\n    document.addEventListener('click', this.handleClick, true);\n    document.body.style.cursor = 'crosshair';\n  }\n  \n  private disable() {\n    this.overlay.deactivate();\n    document.removeEventListener('mousemove', this.handleMouseMove);\n    document.removeEventListener('click', this.handleClick, true);\n    document.body.style.cursor = '';\n    this.closePanel();\n  }\n  \n  private handleMouseMove = (event: MouseEvent) => {\n    if (!this.isEnabled) return;\n    \n    const target = event.target as HTMLElement;\n    \n    // Ignore our own overlay elements\n    if (target.id?.startsWith('pixel-perfect-')) return;\n    \n    // Ignore if panel is open and hovering over panel\n    if (this.panelOpen && this.isHoveringPanel(target)) return;\n    \n    this.currentElement = target;\n    this.overlay.showOnElement(target);\n  };\n  \n  private handleClick = (event: MouseEvent) => {\n    if (!this.isEnabled || !this.currentElement) return;\n    \n    // Prevent default action\n    event.preventDefault();\n    event.stopPropagation();\n    \n    // Extract properties\n    const inspectedElement = this.extractor.createInspectedElement(this.currentElement);\n    \n    // Save to history\n    chrome.runtime.sendMessage({\n      action: 'saveInspectedElement',\n      element: inspectedElement\n    });\n    \n    // Open panel with data\n    this.openPanel(inspectedElement);\n    \n    // Disable inspection mode after selection\n    this.toggle(false);\n    chrome.runtime.sendMessage({ action: 'disableInspection' });\n  };\n  \n  private openPanel(element: InspectedElement) {\n    // Create or update panel\n    let panel = document.getElementById('pixel-perfect-panel') as HTMLDivElement;\n    \n    if (!panel) {\n      panel = document.createElement('div');\n      panel.id = 'pixel-perfect-panel';\n      panel.style.cssText = `\n        position: fixed;\n        top: 0;\n        right: 0;\n        width: 400px;\n        height: 100vh;\n        background: white;\n        box-shadow: -2px 0 10px rgba(0,0,0,0.1);\n        z-index: 2147483646;\n        overflow-y: auto;\n        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n      `;\n      document.body.appendChild(panel);\n    }\n    \n    // Render panel content (will be enhanced in next task)\n    panel.innerHTML = this.renderPanelContent(element);\n    this.panelOpen = true;\n    \n    // Setup close button\n    const closeBtn = panel.querySelector('#close-panel');\n    closeBtn?.addEventListener('click', () => this.closePanel());\n    \n    // Setup copy buttons\n    this.setupCopyButtons(panel, element);\n  }\n  \n  private closePanel() {\n    const panel = document.getElementById('pixel-perfect-panel');\n    panel?.remove();\n    this.panelOpen = false;\n  }\n  \n  private isHoveringPanel(element: HTMLElement): boolean {\n    return element.closest('#pixel-perfect-panel') !== null;\n  }\n  \n  private renderPanelContent(element: InspectedElement): string {\n    // Basic rendering - will be enhanced in panel task\n    return `\n      <div style=\"padding: 20px;\">\n        <div style=\"display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;\">\n          <h2 style=\"margin: 0; font-size: 18px;\">Element: &lt;${element.tagName}&gt;</h2>\n          <button id=\"close-panel\" style=\"cursor: pointer; border: none; background: none; font-size: 24px;\">&times;</button>\n        </div>\n        <div id=\"panel-content\">\n          <pre>${JSON.stringify(element.properties, null, 2)}</pre>\n        </div>\n      </div>\n    `;\n  }\n  \n  private setupCopyButtons(panel: HTMLElement, element: InspectedElement) {\n    // Will be implemented in panel task\n  }\n}\n\n// Initialize inspector\nconst inspector = new PixelPerfectInspector();\n```\n2. Add debouncing to mousemove for performance if needed",
        "testStrategy": "1. Test inspection mode activates/deactivates correctly\n2. Verify hover highlights elements smoothly without lag\n3. Test click captures element and extracts properties\n4. Verify panel opens with correct data\n5. Test that clicking ignores overlay and panel elements\n6. Test cursor changes to crosshair in inspection mode\n7. Test event listeners are properly removed on disable\n8. Test with nested elements (should highlight innermost element)\n9. Verify inspection mode disables after element selection\n10. Performance test: ensure no memory leaks after multiple enable/disable cycles",
        "priority": "high",
        "dependencies": [
          "4",
          "5"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-10T17:31:50.667Z"
      },
      {
        "id": 7,
        "title": "Build Side Panel UI with Property Display",
        "description": "Create a polished side panel interface that displays extracted CSS properties organized by category with proper formatting and styling",
        "details": "1. Create panel/panel.html (standalone version for testing):\n```html\n<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"UTF-8\">\n  <link rel=\"stylesheet\" href=\"panel.css\">\n</head>\n<body>\n  <div id=\"panel-root\"></div>\n  <script src=\"panel.js\"></script>\n</body>\n</html>\n```\n2. Create panel/panel.ts with rendering logic:\n```typescript\nimport { InspectedElement, CSSProperties } from '../shared/types';\n\nexport class PanelRenderer {\n  render(element: InspectedElement): string {\n    return `\n      <div class=\"panel-container\">\n        <div class=\"panel-header\">\n          <div class=\"element-info\">\n            <h2>Element: &lt;${element.tagName}&gt;</h2>\n            ${element.className ? `<p class=\"class-name\">.${element.className}</p>` : ''}\n          </div>\n          <button id=\"close-panel\" class=\"close-btn\" aria-label=\"Close\">&times;</button>\n        </div>\n        \n        <div class=\"panel-content\">\n          ${this.renderTypography(element.properties.typography)}\n          ${this.renderDimensions(element.properties.dimensions)}\n          ${this.renderSpacing(element.properties.spacing)}\n          ${this.renderBorders(element.properties.borders)}\n          ${element.properties.layout ? this.renderLayout(element.properties.layout) : ''}\n        </div>\n        \n        <div class=\"panel-footer\">\n          <button id=\"copy-all\" class=\"btn btn-primary\">Copy All Properties</button>\n          <button id=\"export-json\" class=\"btn btn-secondary\">Export JSON</button>\n          <button id=\"export-css\" class=\"btn btn-secondary\">Export CSS</button>\n        </div>\n      </div>\n    `;\n  }\n  \n  private renderTypography(typography: any): string {\n    return `\n      <section class=\"property-section\">\n        <h3>üìù Typography</h3>\n        <div class=\"property-list\">\n          ${this.renderProperty('Font Family', typography.fontFamily, 'fontFamily')}\n          ${this.renderProperty('Font Size', `${typography.fontSize.value}${typography.fontSize.unit}`, 'fontSize')}\n          ${this.renderProperty('Font Weight', typography.fontWeight, 'fontWeight')}\n          ${this.renderProperty('Line Height', `${typography.lineHeight.value}${typography.lineHeight.unit}`, 'lineHeight')}\n          ${this.renderProperty('Color', typography.color, 'color', typography.color)}\n          ${typography.letterSpacing ? this.renderProperty('Letter Spacing', typography.letterSpacing, 'letterSpacing') : ''}\n          ${typography.textTransform ? this.renderProperty('Text Transform', typography.textTransform, 'textTransform') : ''}\n        </div>\n      </section>\n    `;\n  }\n  \n  private renderDimensions(dimensions: any): string {\n    return `\n      <section class=\"property-section\">\n        <h3>üìè Dimensions</h3>\n        <div class=\"property-list\">\n          ${this.renderProperty('Width', `${dimensions.width.value}${dimensions.width.unit} (${Math.round(dimensions.width.computed)}px)`, 'width')}\n          ${this.renderProperty('Height', `${dimensions.height.value}${dimensions.height.unit} (${Math.round(dimensions.height.computed)}px)`, 'height')}\n          ${dimensions.minWidth ? this.renderProperty('Min Width', dimensions.minWidth, 'minWidth') : ''}\n          ${dimensions.maxWidth ? this.renderProperty('Max Width', dimensions.maxWidth, 'maxWidth') : ''}\n        </div>\n      </section>\n    `;\n  }\n  \n  private renderSpacing(spacing: any): string {\n    const paddingShorthand = this.formatSpacing(spacing.padding);\n    const marginShorthand = this.formatSpacing(spacing.margin);\n    \n    return `\n      <section class=\"property-section\">\n        <h3>üì¶ Spacing</h3>\n        <div class=\"property-list\">\n          ${this.renderProperty('Padding', paddingShorthand, 'padding')}\n          ${this.renderProperty('Margin', marginShorthand, 'margin')}\n          ${spacing.gap ? this.renderProperty('Gap', spacing.gap, 'gap') : ''}\n        </div>\n      </section>\n    `;\n  }\n  \n  private renderBorders(borders: any): string {\n    return `\n      <section class=\"property-section\">\n        <h3>üî≤ Borders</h3>\n        <div class=\"property-list\">\n          ${this.renderProperty('Border Radius', borders.borderRadius.topLeft, 'borderRadius')}\n          ${this.renderProperty('Border', `${borders.border.width} ${borders.border.style} ${borders.border.color}`, 'border')}\n        </div>\n      </section>\n    `;\n  }\n  \n  private renderLayout(layout: any): string {\n    return `\n      <section class=\"property-section\">\n        <h3>üìê Layout</h3>\n        <div class=\"property-list\">\n          ${this.renderProperty('Display', layout.display, 'display')}\n          ${this.renderProperty('Position', layout.position, 'position')}\n          ${layout.flexDirection ? this.renderProperty('Flex Direction', layout.flexDirection, 'flexDirection') : ''}\n          ${layout.justifyContent ? this.renderProperty('Justify Content', layout.justifyContent, 'justifyContent') : ''}\n          ${layout.alignItems ? this.renderProperty('Align Items', layout.alignItems, 'alignItems') : ''}\n        </div>\n      </section>\n    `;\n  }\n  \n  private renderProperty(label: string, value: string, propName: string, colorPreview?: string): string {\n    return `\n      <div class=\"property-row\">\n        <span class=\"property-label\">${label}:</span>\n        <span class=\"property-value\">\n          ${colorPreview ? `<span class=\"color-preview\" style=\"background: ${colorPreview};\"></span>` : ''}\n          ${value}\n        </span>\n        <button class=\"copy-btn\" data-property=\"${propName}\" data-value=\"${value}\" title=\"Copy\">üìã</button>\n      </div>\n    `;\n  }\n  \n  private formatSpacing(spacing: any): string {\n    const { top, right, bottom, left } = spacing;\n    if (top === right && right === bottom && bottom === left) {\n      return top;\n    }\n    if (top === bottom && left === right) {\n      return `${top} ${right}`;\n    }\n    return `${top} ${right} ${bottom} ${left}`;\n  }\n}\n```\n3. Create panel/panel.css with modern styling:\n```css\n.panel-container {\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n  background: #ffffff;\n  height: 100%;\n  display: flex;\n  flex-direction: column;\n}\n\n.panel-header {\n  padding: 20px;\n  border-bottom: 1px solid #e5e5e5;\n  display: flex;\n  justify-content: space-between;\n  align-items: flex-start;\n}\n\n.element-info h2 {\n  margin: 0;\n  font-size: 18px;\n  font-weight: 600;\n  color: #1a1a1a;\n}\n\n.class-name {\n  margin: 4px 0 0 0;\n  font-size: 14px;\n  color: #666;\n  font-family: 'Monaco', 'Courier New', monospace;\n}\n\n.close-btn {\n  background: none;\n  border: none;\n  font-size: 28px;\n  cursor: pointer;\n  color: #666;\n  line-height: 1;\n  padding: 0;\n  width: 32px;\n  height: 32px;\n}\n\n.close-btn:hover {\n  color: #000;\n}\n\n.panel-content {\n  flex: 1;\n  overflow-y: auto;\n  padding: 20px;\n}\n\n.property-section {\n  margin-bottom: 24px;\n}\n\n.property-section h3 {\n  font-size: 14px;\n  font-weight: 600;\n  color: #1a1a1a;\n  margin: 0 0 12px 0;\n  text-transform: uppercase;\n  letter-spacing: 0.5px;\n}\n\n.property-list {\n  display: flex;\n  flex-direction: column;\n  gap: 8px;\n}\n\n.property-row {\n  display: flex;\n  align-items: center;\n  padding: 8px;\n  background: #f9f9f9;\n  border-radius: 6px;\n  font-size: 13px;\n}\n\n.property-label {\n  font-weight: 500;\n  color: #666;\n  min-width: 120px;\n}\n\n.property-value {\n  flex: 1;\n  font-family: 'Monaco', 'Courier New', monospace;\n  color: #1a1a1a;\n  display: flex;\n  align-items: center;\n  gap: 8px;\n}\n\n.color-preview {\n  width: 16px;\n  height: 16px;\n  border-radius: 3px;\n  border: 1px solid #ddd;\n  display: inline-block;\n}\n\n.copy-btn {\n  background: none;\n  border: none;\n  cursor: pointer;\n  font-size: 16px;\n  opacity: 0.5;\n  padding: 4px;\n}\n\n.copy-btn:hover {\n  opacity: 1;\n}\n\n.panel-footer {\n  padding: 20px;\n  border-top: 1px solid #e5e5e5;\n  display: flex;\n  flex-direction: column;\n  gap: 8px;\n}\n\n.btn {\n  padding: 10px 16px;\n  border-radius: 6px;\n  border: none;\n  font-size: 14px;\n  font-weight: 500;\n  cursor: pointer;\n  transition: all 0.2s;\n}\n\n.btn-primary {\n  background: #007AFF;\n  color: white;\n}\n\n.btn-primary:hover {\n  background: #0051D5;\n}\n\n.btn-secondary {\n  background: #f0f0f0;\n  color: #1a1a1a;\n}\n\n.btn-secondary:hover {\n  background: #e0e0e0;\n}\n```\n4. Update inspector.ts to use PanelRenderer",
        "testStrategy": "1. Test panel renders all property categories correctly\n2. Verify formatting of spacing shorthand (padding/margin)\n3. Test color preview squares display correctly\n4. Verify responsive layout at different viewport heights\n5. Test scrolling works when content exceeds viewport\n6. Verify all buttons are clickable and styled correctly\n7. Test with elements having minimal CSS vs complex CSS\n8. Verify typography, dimensions, spacing, borders, and layout sections all render\n9. Test close button functionality\n10. Visual QA: ensure design matches PRD mockup",
        "priority": "medium",
        "dependencies": [
          "6"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-10T17:49:53.939Z"
      },
      {
        "id": 8,
        "title": "Implement Copy and Export Functionality",
        "description": "Add functionality to copy individual properties, copy all properties, and export data in JSON and CSS formats",
        "details": "1. Create shared/clipboard.ts:\n```typescript\nexport class ClipboardManager {\n  static async copyToClipboard(text: string): Promise<boolean> {\n    try {\n      await navigator.clipboard.writeText(text);\n      return true;\n    } catch (err) {\n      // Fallback for older browsers\n      const textarea = document.createElement('textarea');\n      textarea.value = text;\n      textarea.style.position = 'fixed';\n      textarea.style.opacity = '0';\n      document.body.appendChild(textarea);\n      textarea.select();\n      const success = document.execCommand('copy');\n      document.body.removeChild(textarea);\n      return success;\n    }\n  }\n  \n  static showCopyFeedback(button: HTMLElement) {\n    const originalText = button.textContent;\n    button.textContent = '‚úì';\n    button.style.color = '#00C853';\n    setTimeout(() => {\n      button.textContent = originalText;\n      button.style.color = '';\n    }, 1000);\n  }\n}\n```\n2. Create shared/exporters.ts:\n```typescript\nimport { InspectedElement, CSSProperties } from './types';\n\nexport class DataExporter {\n  static toJSON(element: InspectedElement): string {\n    return JSON.stringify(element, null, 2);\n  }\n  \n  static toCSS(element: InspectedElement): string {\n    const { properties } = element;\n    const lines: string[] = [];\n    \n    lines.push(`${element.selector} {`);\n    \n    // Typography\n    const t = properties.typography;\n    lines.push(`  font-family: ${t.fontFamily};`);\n    lines.push(`  font-size: ${t.fontSize.value}${t.fontSize.unit};`);\n    lines.push(`  font-weight: ${t.fontWeight};`);\n    lines.push(`  line-height: ${t.lineHeight.value}${t.lineHeight.unit};`);\n    lines.push(`  color: ${t.color};`);\n    if (t.letterSpacing) lines.push(`  letter-spacing: ${t.letterSpacing};`);\n    if (t.textTransform) lines.push(`  text-transform: ${t.textTransform};`);\n    \n    // Dimensions\n    const d = properties.dimensions;\n    lines.push(`  width: ${d.width.value}${d.width.unit};`);\n    lines.push(`  height: ${d.height.value}${d.height.unit};`);\n    if (d.minWidth) lines.push(`  min-width: ${d.minWidth};`);\n    if (d.maxWidth) lines.push(`  max-width: ${d.maxWidth};`);\n    \n    // Spacing\n    const s = properties.spacing;\n    const padding = this.formatSpacingForCSS('padding', s.padding);\n    const margin = this.formatSpacingForCSS('margin', s.margin);\n    lines.push(`  ${padding}`);\n    lines.push(`  ${margin}`);\n    if (s.gap) lines.push(`  gap: ${s.gap};`);\n    \n    // Borders\n    const b = properties.borders;\n    if (this.isUniformBorderRadius(b.borderRadius)) {\n      lines.push(`  border-radius: ${b.borderRadius.topLeft};`);\n    } else {\n      lines.push(`  border-radius: ${b.borderRadius.topLeft} ${b.borderRadius.topRight} ${b.borderRadius.bottomRight} ${b.borderRadius.bottomLeft};`);\n    }\n    lines.push(`  border: ${b.border.width} ${b.border.style} ${b.border.color};`);\n    \n    // Layout\n    if (properties.layout) {\n      const l = properties.layout;\n      lines.push(`  display: ${l.display};`);\n      lines.push(`  position: ${l.position};`);\n      if (l.flexDirection) lines.push(`  flex-direction: ${l.flexDirection};`);\n      if (l.justifyContent) lines.push(`  justify-content: ${l.justifyContent};`);\n      if (l.alignItems) lines.push(`  align-items: ${l.alignItems};`);\n    }\n    \n    lines.push('}');\n    return lines.join('\\n');\n  }\n  \n  private static formatSpacingForCSS(property: string, spacing: any): string {\n    const { top, right, bottom, left } = spacing;\n    if (top === right && right === bottom && bottom === left) {\n      return `${property}: ${top};`;\n    }\n    if (top === bottom && left === right) {\n      return `${property}: ${top} ${right};`;\n    }\n    return `${property}: ${top} ${right} ${bottom} ${left};`;\n  }\n  \n  private static isUniformBorderRadius(radius: any): boolean {\n    const { topLeft, topRight, bottomRight, bottomLeft } = radius;\n    return topLeft === topRight && topRight === bottomRight && bottomRight === bottomLeft;\n  }\n  \n  static downloadFile(content: string, filename: string, mimeType: string) {\n    const blob = new Blob([content], { type: mimeType });\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = filename;\n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n    URL.revokeObjectURL(url);\n  }\n}\n```\n3. Update inspector.ts setupCopyButtons method:\n```typescript\nprivate setupCopyButtons(panel: HTMLElement, element: InspectedElement) {\n  // Individual property copy buttons\n  panel.querySelectorAll('.copy-btn').forEach(btn => {\n    btn.addEventListener('click', async (e) => {\n      const target = e.target as HTMLElement;\n      const value = target.getAttribute('data-value');\n      if (value) {\n        await ClipboardManager.copyToClipboard(value);\n        ClipboardManager.showCopyFeedback(target);\n      }\n    });\n  });\n  \n  // Copy all button\n  const copyAllBtn = panel.querySelector('#copy-all');\n  copyAllBtn?.addEventListener('click', async () => {\n    const cssText = DataExporter.toCSS(element);\n    await ClipboardManager.copyToClipboard(cssText);\n    ClipboardManager.showCopyFeedback(copyAllBtn as HTMLElement);\n  });\n  \n  // Export JSON button\n  const exportJsonBtn = panel.querySelector('#export-json');\n  exportJsonBtn?.addEventListener('click', () => {\n    const json = DataExporter.toJSON(element);\n    const filename = `${element.selector.replace(/[^a-z0-9]/gi, '-')}-${Date.now()}.json`;\n    DataExporter.downloadFile(json, filename, 'application/json');\n  });\n  \n  // Export CSS button\n  const exportCssBtn = panel.querySelector('#export-css');\n  exportCssBtn?.addEventListener('click', () => {\n    const css = DataExporter.toCSS(element);\n    const filename = `${element.selector.replace(/[^a-z0-9]/gi, '-')}-${Date.now()}.css`;\n    DataExporter.downloadFile(css, filename, 'text/css');\n  });\n}\n```",
        "testStrategy": "1. Test copying individual properties shows feedback and copies to clipboard\n2. Test 'Copy All' button generates valid CSS and copies to clipboard\n3. Test JSON export downloads valid JSON file\n4. Test CSS export downloads valid CSS file\n5. Verify exported CSS is properly formatted and usable\n6. Test clipboard fallback for browsers without Clipboard API\n7. Verify copy feedback animation works (checkmark appears for 1 second)\n8. Test with various element types and property combinations\n9. Verify exported filenames are valid and include timestamp\n10. Test that exported CSS can be pasted into a stylesheet and works correctly",
        "priority": "medium",
        "dependencies": [
          "7"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-10T17:50:55.404Z"
      },
      {
        "id": 9,
        "title": "Implement Popup UI and History Feature",
        "description": "Create the extension popup interface with inspection mode toggle, settings, and history of inspected elements",
        "details": "1. Create popup/popup.html:\n```html\n<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <link rel=\"stylesheet\" href=\"popup.css\">\n  <title>Pixel Perfect Inspector</title>\n</head>\n<body>\n  <div class=\"popup-container\">\n    <header class=\"popup-header\">\n      <h1>Pixel Perfect Inspector</h1>\n    </header>\n    \n    <section class=\"inspection-control\">\n      <div class=\"toggle-container\">\n        <label class=\"toggle-label\">\n          <span>Inspection Mode</span>\n          <div class=\"toggle-switch\">\n            <input type=\"checkbox\" id=\"inspection-toggle\">\n            <span class=\"slider\"></span>\n          </div>\n        </label>\n      </div>\n      <p class=\"status-text\" id=\"status-text\">Click to activate inspection mode</p>\n    </section>\n    \n    <section class=\"history-section\">\n      <h2>Recent Inspections</h2>\n      <div id=\"history-list\" class=\"history-list\">\n        <!-- History items will be inserted here -->\n      </div>\n    </section>\n    \n    <section class=\"shortcuts-section\">\n      <h2>Keyboard Shortcuts</h2>\n      <ul class=\"shortcuts-list\">\n        <li><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>I</kbd> - Toggle Inspection</li>\n        <li><kbd>Esc</kbd> - Exit Inspection Mode</li>\n      </ul>\n    </section>\n    \n    <footer class=\"popup-footer\">\n      <button id=\"clear-history\" class=\"btn-link\">Clear History</button>\n      <a href=\"#\" id=\"settings-link\" class=\"btn-link\">Settings</a>\n    </footer>\n  </div>\n  <script src=\"popup.js\"></script>\n</body>\n</html>\n```\n2. Create popup/popup.ts:\n```typescript\nclass PopupController {\n  private inspectionToggle: HTMLInputElement;\n  private statusText: HTMLElement;\n  private historyList: HTMLElement;\n  \n  constructor() {\n    this.inspectionToggle = document.getElementById('inspection-toggle') as HTMLInputElement;\n    this.statusText = document.getElementById('status-text') as HTMLElement;\n    this.historyList = document.getElementById('history-list') as HTMLElement;\n    \n    this.init();\n  }\n  \n  async init() {\n    // Get current inspection state\n    const tabs = await chrome.tabs.query({ active: true, currentWindow: true });\n    if (tabs[0]?.id) {\n      chrome.tabs.sendMessage(tabs[0].id, { action: 'getInspectionState' }, (response) => {\n        if (response?.enabled) {\n          this.inspectionToggle.checked = true;\n          this.updateStatus(true);\n        }\n      });\n    }\n    \n    // Setup event listeners\n    this.inspectionToggle.addEventListener('change', () => this.handleToggle());\n    document.getElementById('clear-history')?.addEventListener('click', () => this.clearHistory());\n    \n    // Load history\n    this.loadHistory();\n  }\n  \n  async handleToggle() {\n    const enabled = this.inspectionToggle.checked;\n    const tabs = await chrome.tabs.query({ active: true, currentWindow: true });\n    \n    if (tabs[0]?.id) {\n      chrome.tabs.sendMessage(tabs[0].id, {\n        action: 'toggleInspection',\n        enabled\n      });\n      this.updateStatus(enabled);\n    }\n  }\n  \n  updateStatus(enabled: boolean) {\n    if (enabled) {\n      this.statusText.textContent = '‚úì Inspection mode active - hover over elements';\n      this.statusText.style.color = '#00C853';\n    } else {\n      this.statusText.textContent = 'Click to activate inspection mode';\n      this.statusText.style.color = '#666';\n    }\n  }\n  \n  async loadHistory() {\n    chrome.storage.local.get(['history'], (result) => {\n      const history = result.history || [];\n      \n      if (history.length === 0) {\n        this.historyList.innerHTML = '<p class=\"empty-state\">No inspections yet</p>';\n        return;\n      }\n      \n      this.historyList.innerHTML = history.map((item: any) => `\n        <div class=\"history-item\" data-id=\"${item.id}\">\n          <div class=\"history-item-header\">\n            <span class=\"element-tag\">&lt;${item.tagName}&gt;</span>\n            ${item.className ? `<span class=\"element-class\">.${item.className.split(' ')[0]}</span>` : ''}\n          </div>\n          <div class=\"history-item-meta\">\n            <span class=\"timestamp\">${this.formatTimestamp(item.timestamp)}</span>\n            <span class=\"dimensions\">${Math.round(item.position.width)}√ó${Math.round(item.position.height)}px</span>\n          </div>\n        </div>\n      `).join('');\n      \n      // Add click handlers to history items\n      this.historyList.querySelectorAll('.history-item').forEach(item => {\n        item.addEventListener('click', () => {\n          const id = item.getAttribute('data-id');\n          this.loadHistoryItem(id);\n        });\n      });\n    });\n  }\n  \n  formatTimestamp(timestamp: number): string {\n    const now = Date.now();\n    const diff = now - timestamp;\n    const minutes = Math.floor(diff / 60000);\n    const hours = Math.floor(diff / 3600000);\n    \n    if (minutes < 1) return 'Just now';\n    if (minutes < 60) return `${minutes}m ago`;\n    if (hours < 24) return `${hours}h ago`;\n    return new Date(timestamp).toLocaleDateString();\n  }\n  \n  async loadHistoryItem(id: string | null) {\n    // Send message to content script to re-open panel with this element\n    const tabs = await chrome.tabs.query({ active: true, currentWindow: true });\n    if (tabs[0]?.id && id) {\n      chrome.tabs.sendMessage(tabs[0].id, {\n        action: 'loadHistoryItem',\n        id\n      });\n      window.close();\n    }\n  }\n  \n  clearHistory() {\n    if (confirm('Clear all inspection history?')) {\n      chrome.storage.local.set({ history: [] }, () => {\n        this.loadHistory();\n      });\n    }\n  }\n}\n\n// Initialize popup\nnew PopupController();\n```\n3. Create popup/popup.css:\n```css\nbody {\n  width: 320px;\n  margin: 0;\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n  background: #ffffff;\n}\n\n.popup-container {\n  padding: 16px;\n}\n\n.popup-header h1 {\n  margin: 0 0 16px 0;\n  font-size: 18px;\n  font-weight: 600;\n  color: #1a1a1a;\n}\n\n.inspection-control {\n  padding: 16px;\n  background: #f9f9f9;\n  border-radius: 8px;\n  margin-bottom: 16px;\n}\n\n.toggle-container {\n  margin-bottom: 8px;\n}\n\n.toggle-label {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  cursor: pointer;\n  font-weight: 500;\n}\n\n.toggle-switch {\n  position: relative;\n  width: 48px;\n  height: 24px;\n}\n\n.toggle-switch input {\n  opacity: 0;\n  width: 0;\n  height: 0;\n}\n\n.slider {\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background-color: #ccc;\n  border-radius: 24px;\n  transition: 0.3s;\n}\n\n.slider:before {\n  position: absolute;\n  content: \"\";\n  height: 18px;\n  width: 18px;\n  left: 3px;\n  bottom: 3px;\n  background-color: white;\n  border-radius: 50%;\n  transition: 0.3s;\n}\n\ninput:checked + .slider {\n  background-color: #007AFF;\n}\n\ninput:checked + .slider:before {\n  transform: translateX(24px);\n}\n\n.status-text {\n  margin: 0;\n  font-size: 13px;\n  color: #666;\n}\n\n.history-section,\n.shortcuts-section {\n  margin-bottom: 16px;\n}\n\n.history-section h2,\n.shortcuts-section h2 {\n  font-size: 14px;\n  font-weight: 600;\n  margin: 0 0 8px 0;\n  color: #1a1a1a;\n}\n\n.history-list {\n  max-height: 200px;\n  overflow-y: auto;\n}\n\n.history-item {\n  padding: 10px;\n  background: #f9f9f9;\n  border-radius: 6px;\n  margin-bottom: 6px;\n  cursor: pointer;\n  transition: background 0.2s;\n}\n\n.history-item:hover {\n  background: #f0f0f0;\n}\n\n.history-item-header {\n  display: flex;\n  gap: 8px;\n  margin-bottom: 4px;\n}\n\n.element-tag {\n  font-family: 'Monaco', 'Courier New', monospace;\n  font-size: 12px;\n  color: #007AFF;\n  font-weight: 600;\n}\n\n.element-class {\n  font-family: 'Monaco', 'Courier New', monospace;\n  font-size: 12px;\n  color: #666;\n}\n\n.history-item-meta {\n  display: flex;\n  justify-content: space-between;\n  font-size: 11px;\n  color: #999;\n}\n\n.empty-state {\n  text-align: center;\n  color: #999;\n  font-size: 13px;\n  padding: 20px;\n}\n\n.shortcuts-list {\n  list-style: none;\n  padding: 0;\n  margin: 0;\n}\n\n.shortcuts-list li {\n  padding: 6px 0;\n  font-size: 13px;\n  color: #666;\n}\n\nkbd {\n  background: #f0f0f0;\n  border: 1px solid #ccc;\n  border-radius: 3px;\n  padding: 2px 6px;\n  font-size: 11px;\n  font-family: monospace;\n}\n\n.popup-footer {\n  display: flex;\n  justify-content: space-between;\n  padding-top: 12px;\n  border-top: 1px solid #e5e5e5;\n}\n\n.btn-link {\n  background: none;\n  border: none;\n  color: #007AFF;\n  font-size: 13px;\n  cursor: pointer;\n  text-decoration: none;\n}\n\n.btn-link:hover {\n  text-decoration: underline;\n}\n```",
        "testStrategy": "1. Test popup opens when clicking extension icon\n2. Verify toggle switch reflects current inspection state\n3. Test toggling inspection mode from popup\n4. Verify history loads and displays recent inspections\n5. Test clicking history item re-opens that element's panel\n6. Test 'Clear History' button clears all history\n7. Verify timestamp formatting (just now, Xm ago, Xh ago)\n8. Test popup with empty history shows empty state\n9. Verify keyboard shortcuts are displayed correctly\n10. Test popup UI is responsive and fits within 320px width\n11. Verify status text updates when inspection mode changes",
        "priority": "medium",
        "dependencies": [
          "3",
          "8"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-10T17:52:55.553Z"
      },
      {
        "id": 10,
        "title": "Testing, Documentation, and Chrome Web Store Preparation",
        "description": "Comprehensive testing, create documentation, prepare extension assets, and package for Chrome Web Store submission",
        "details": "1. Create comprehensive test suite:\n   - Manual test checklist covering all features\n   - Test on different websites (localhost, HTTPS sites)\n   - Test with various element types (text, images, containers, flex, grid)\n   - Performance testing (memory usage, extraction speed)\n   - Cross-browser testing (Chrome 100+, Edge 100+)\n   - Test with complex nested elements\n   - Test with pseudo-elements and shadow DOM\n   \n2. Create README.md:\n```markdown\n# Pixel Perfect Inspector\n\nA Chrome extension for inspecting and extracting CSS properties from DOM elements.\n\n## Features\n- üéØ Hover to highlight elements\n- üìã One-click property copying\n- üì§ Export as JSON or CSS\n- üìä Inspection history\n- ‚å®Ô∏è Keyboard shortcuts\n\n## Installation\n1. Download from Chrome Web Store\n2. Or load unpacked: Clone repo, run `npm install && npm run build`, load `dist` folder\n\n## Usage\n1. Click extension icon to activate inspection mode\n2. Hover over elements to highlight\n3. Click to inspect and view properties\n4. Copy individual properties or export all\n\n## Development\n```bash\nnpm install\nnpm run dev    # Development mode with hot reload\nnpm run build  # Production build\n```\n\n## Tech Stack\n- TypeScript 5+\n- Vite\n- Chrome Extension Manifest V3\n\n## License\nMIT\n```\n\n3. Create CHANGELOG.md:\n```markdown\n# Changelog\n\n## [1.0.0] - 2025-01-XX\n### Added\n- Initial release\n- Element inspection with hover highlighting\n- CSS property extraction (typography, spacing, dimensions, borders, layout)\n- Side panel with categorized properties\n- Copy individual properties\n- Export as JSON/CSS\n- Inspection history (last 10 elements)\n- Keyboard shortcuts\n```\n\n4. Create extension assets:\n   - Design icons: 16x16, 48x48, 128x128 PNG\n   - Create promotional images for Chrome Web Store:\n     - Small tile: 440x280\n     - Large tile: 920x680\n     - Marquee: 1400x560\n   - Create screenshots (1280x800 or 640x400)\n   - Record demo video (optional, max 30 seconds)\n\n5. Write Chrome Web Store listing:\n   - Title: \"Pixel Perfect Inspector - CSS Property Extractor\"\n   - Short description (132 chars): \"Inspect and extract CSS properties from any element. Perfect for developers ensuring pixel-perfect implementations.\"\n   - Detailed description (16,000 chars max):\n```\nPixel Perfect Inspector helps developers and designers quickly inspect and extract CSS properties from DOM elements.\n\n‚ú® KEY FEATURES:\n‚Ä¢ Hover Highlighting - Visual overlay shows element boundaries\n‚Ä¢ Comprehensive Property Extraction - Typography, spacing, dimensions, borders, and layout\n‚Ä¢ One-Click Copying - Copy individual properties or entire CSS blocks\n‚Ä¢ Export Options - Download as JSON or CSS files\n‚Ä¢ Inspection History - Quick access to recently inspected elements\n‚Ä¢ Keyboard Shortcuts - Efficient workflow with hotkeys\n‚Ä¢ Clean Interface - Non-intrusive side panel design\n\nüéØ PERFECT FOR:\n‚Ä¢ Frontend developers verifying design implementations\n‚Ä¢ UI/UX designers checking spacing and typography\n‚Ä¢ QA engineers validating pixel-perfect accuracy\n‚Ä¢ Anyone learning CSS and web development\n\nüöÄ HOW TO USE:\n1. Click the extension icon to activate inspection mode\n2. Hover over any element to see its dimensions\n3. Click to open the detailed property panel\n4. Copy properties or export for documentation\n\nüîí PRIVACY:\n‚Ä¢ No data collection or tracking\n‚Ä¢ Works entirely locally in your browser\n‚Ä¢ Only activates when you explicitly enable it\n‚Ä¢ Minimal permissions (activeTab, storage)\n\n‚å®Ô∏è KEYBOARD SHORTCUTS:\n‚Ä¢ Ctrl+Shift+I (Cmd+Shift+I on Mac) - Toggle inspection mode\n‚Ä¢ Esc - Exit inspection mode\n\nSupport: [GitHub Issues URL]\nDocumentation: [GitHub README URL]\n```\n\n6. Prepare for submission:\n   - Update manifest.json version to 1.0.0\n   - Add privacy policy URL (if collecting any data)\n   - Create ZIP file of dist folder\n   - Fill out Chrome Web Store Developer Dashboard\n   - Submit for review\n\n7. Create user documentation:\n   - Quick start guide\n   - Feature documentation\n   - Troubleshooting guide\n   - FAQ\n\n8. Performance optimization:\n   - Minify and bundle code\n   - Optimize icon file sizes\n   - Remove console.logs from production\n   - Test memory usage < 50MB\n   - Verify extraction speed < 50ms\n\n9. Final QA checklist:\n   - [ ] All features work as specified in PRD\n   - [ ] No console errors\n   - [ ] Extension loads without warnings\n   - [ ] Popup UI is polished\n   - [ ] Panel UI is polished\n   - [ ] Overlay is smooth and responsive\n   - [ ] Copy/export functions work\n   - [ ] History persists correctly\n   - [ ] Keyboard shortcuts work\n   - [ ] Works on localhost\n   - [ ] Works on HTTPS sites\n   - [ ] Performance meets requirements\n   - [ ] Icons display correctly\n   - [ ] README is complete\n   - [ ] All dependencies are properly licensed",
        "testStrategy": "1. Execute full manual test suite on multiple websites\n2. Verify all acceptance criteria from PRD are met\n3. Performance testing: memory usage, extraction speed, UI responsiveness\n4. Cross-browser testing on Chrome and Edge\n5. Test installation from unpacked extension\n6. Verify all documentation is accurate and complete\n7. Test with real-world use cases from PRD (typography check, spacing analysis, layout debug)\n8. Validate Chrome Web Store assets meet requirements\n9. Peer review of code and documentation\n10. Final smoke test after packaging for submission\n11. Verify extension meets all Chrome Web Store policies\n12. Test on different operating systems (Windows, macOS, Linux)",
        "priority": "medium",
        "dependencies": [
          "9"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-10T17:59:40.785Z"
      },
      {
        "id": 11,
        "title": "Melhorar contraste do tooltip",
        "description": "Ajustar background e cor do texto do tooltip para melhor legibilidade, mantendo a identidade visual roxa/rosa. O tooltip atual n√£o tem contraste suficiente entre background e texto.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2025-12-10T19:20:34.544Z"
      },
      {
        "id": 12,
        "title": "Atualizar √≠cones com cores do app",
        "description": "Gerar novos √≠cones da extens√£o usando as cores do app (roxo/rosa) ao inv√©s de azul. Atualizar todos os tamanhos (16x16, 48x48, 128x128) e vers√µes ativas.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2025-12-10T19:20:54.430Z"
      },
      {
        "id": 13,
        "title": "Remover Shift para medir dist√¢ncia",
        "description": "Remover a necessidade de apertar Shift para medir dist√¢ncia entre elementos. A funcionalidade principal j√° usa tooltip, ent√£o ser√° mais f√°cil apenas clicar para calcular dist√¢ncia.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2025-12-10T20:38:19.589Z"
      },
      {
        "id": 14,
        "title": "Adicionar prefer√™ncias de cores no popup",
        "description": "Implementar sele√ß√£o de cores no popup que ser√° salva no localStorage. O usu√°rio poder√° escolher entre algumas op√ß√µes de cores que aparecer√£o ao clicar na extens√£o.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2025-12-10T20:41:32.054Z"
      },
      {
        "id": 15,
        "title": "Adicionar controle de tamanho de texto do tooltip",
        "description": "Adicionar controle no popup para aumentar ou diminuir o tamanho do texto que aparece nos tooltips. A prefer√™ncia ser√° salva no localStorage.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2025-12-10T20:41:32.055Z"
      },
      {
        "id": 16,
        "title": "Otimizar layout do popup para ser mais compacto",
        "description": "Redesenhar o popup para ser mais sucinto e funcional, economizando espa√ßo. Cada item deve ter no m√°ximo duas linhas de explica√ß√£o. Fazer caber tudo em uma janela ao clicar na extens√£o.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2025-12-10T20:41:32.057Z"
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-12-10T20:41:32.057Z",
      "taskCount": 16,
      "completedCount": 16,
      "tags": [
        "master"
      ],
      "created": "2025-12-10T20:41:59.004Z",
      "description": "Tasks for master context",
      "updated": "2025-12-10T20:41:59.004Z"
    }
  }
}